# Supporting Information

This page summaries some background information related to compiler support, debugger, how the stack trace are found and how the symbol names are got. It's not for directly tracing/profiling use but for better understanding of internals underneath the front-end tools/methods.

Contents
- [Stack Trace](#stack-trace)
- [Symbol Information](#symbol-information)
- [gprof Tracing Information](#gprof-tracing-information)
- [Ptrace syscall](#ptrace-syscall)

## Stack Trace

### debuginfo: ELF DWARF format

Normal debug info we get by gcc `-g` option.

Save in ELF section, CPU intensive to use.

### ORC (Oops Rewind Capability)

A new debug information format saved in ELF section, which can be used for unwinding stack. The ORC data consists of unwind tables which are generated by objtool.

Simpler in format but easier and faster for stack trace. Less CPU intensive than DWARF.

x86 only. And not available for user space.

[ORC in kernel doc](https://www.kernel.org/doc/html/latest/x86/orc-unwinder.html)

### x86 RBP register as frame pointer

Originally RBP is frame pointer register, making debugger or tracer easily use itto walk stack.

But gcc option `-fomit-frame-pointer` (enabled by `-O` and higher) will make it a general register. This is optimization especially for i386, but not as useful as for x64.

### Intel CPU Last Branch Record (LBR)

Intel CPU feature to record branches in hardware buffer, no runtime overhead but there's penalty to read these registers. Branches numbers are limited in size, for example Haswell can record 16 and Skylake can do 32, Atom can do only 8.

### Intel CPU Processor Trace (Intel PT)

Intel CPU has a new HW extension for capturing software execution since Broadwell. It saves information into data packets for later software analysis. So it's possible to reconstruct stack info from branch info.

## Symbol Information

Symbols are the readable strings for functions, global variables etc.. When debugging/profiling they are needed to make the stack info readable, otherwise we get only "??/kallsyms/unknown" etc. so not helpful at all.

### User space

Symbols information are available if the symbol table sections (symtab and dynsym) in ELF file are available. The section symtab contains all the symbols, while section dynsym contains only global dynamic symbols for linking.

Sometimes pre-built files are released with symtab removed, like using `strip` to reduce size, then if it's a shared library, only exported symbols can be found; if it's executable, no symbol can be found by uprobe. So do not strip ELF files if you need call stack function names when debugging.

Symbols can be retrieved in separate debuginfo files or BTF (BPF Type Format, new and not ready?). Linux distributions normally release the debuginfo files packages with the suffix -dbg/-debuginfo after original package names, like on Debian for libc6 there's a libc6-dbg package.

### Kernel symbols

For kernel symbol information to be used by `perf`, It should be provided by kernel via */proc/kallsyms*, but it's sometimes disabled. Run `echo 0 > /proc/sys/kernel/kptr_restrict` to enable it. */proc/kallsyms* is dynamic so loaded modules' symbols are also available.

## gprof Tracing Information

GCC option `-pg` will generate extra code for gprof profiling tool, it will insert `mcount` function call into program to gather metrics. Using `gprof`, executable will dump gprof data file after exiting, including call-graph, function call counts, function run time etc.

BTW, in kernel space Ftrace will use `mcount` for function tracer.

## Ptrace Syscall

The `ptrace` syscall of Linux is used for one process to access another process's low-level information and control its execution. This is what the debuggers use for debugging another process.
